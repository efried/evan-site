-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Github.Query exposing (..)

import Github.Enum.DependencyGraphEcosystem
import Github.Enum.EnterpriseAdministratorRole
import Github.Enum.SearchType
import Github.Enum.SecurityAdvisoryClassification
import Github.Enum.SecurityAdvisoryEcosystem
import Github.Enum.SecurityAdvisorySeverity
import Github.InputObject
import Github.Interface
import Github.Object
import Github.Scalar
import Github.ScalarCodecs
import Github.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias CodeOfConductRequiredArguments =
    { key : String }


{-| Look up a code of conduct by its key

  - key - The code of conduct's key

-}
codeOfConduct :
    CodeOfConductRequiredArguments
    -> SelectionSet decodesTo Github.Object.CodeOfConduct
    -> SelectionSet (Maybe decodesTo) RootQuery
codeOfConduct requiredArgs____ object____ =
    Object.selectionForCompositeField "codeOfConduct" [ Argument.required "key" requiredArgs____.key Encode.string ] object____ (Basics.identity >> Decode.nullable)


{-| Look up a code of conduct by its key
-}
codesOfConduct :
    SelectionSet decodesTo Github.Object.CodeOfConduct
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootQuery
codesOfConduct object____ =
    Object.selectionForCompositeField "codesOfConduct" [] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias EnterpriseOptionalArguments =
    { invitationToken : OptionalArgument String }


type alias EnterpriseRequiredArguments =
    { slug : String }


{-| Look up an enterprise by URL slug.

  - slug - The enterprise URL slug.
  - invitationToken - The enterprise invitation token.

-}
enterprise :
    (EnterpriseOptionalArguments -> EnterpriseOptionalArguments)
    -> EnterpriseRequiredArguments
    -> SelectionSet decodesTo Github.Object.Enterprise
    -> SelectionSet (Maybe decodesTo) RootQuery
enterprise fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { invitationToken = Absent }

        optionalArgs____ =
            [ Argument.optional "invitationToken" filledInOptionals____.invitationToken Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "enterprise" (optionalArgs____ ++ [ Argument.required "slug" requiredArgs____.slug Encode.string ]) object____ (Basics.identity >> Decode.nullable)


type alias EnterpriseAdministratorInvitationRequiredArguments =
    { userLogin : String
    , enterpriseSlug : String
    , role : Github.Enum.EnterpriseAdministratorRole.EnterpriseAdministratorRole
    }


{-| Look up a pending enterprise administrator invitation by invitee, enterprise and role.

  - userLogin - The login of the user invited to join the business.
  - enterpriseSlug - The slug of the enterprise the user was invited to join.
  - role - The role for the business member invitation.

-}
enterpriseAdministratorInvitation :
    EnterpriseAdministratorInvitationRequiredArguments
    -> SelectionSet decodesTo Github.Object.EnterpriseAdministratorInvitation
    -> SelectionSet (Maybe decodesTo) RootQuery
enterpriseAdministratorInvitation requiredArgs____ object____ =
    Object.selectionForCompositeField "enterpriseAdministratorInvitation" [ Argument.required "userLogin" requiredArgs____.userLogin Encode.string, Argument.required "enterpriseSlug" requiredArgs____.enterpriseSlug Encode.string, Argument.required "role" requiredArgs____.role (Encode.enum Github.Enum.EnterpriseAdministratorRole.toString) ] object____ (Basics.identity >> Decode.nullable)


type alias EnterpriseAdministratorInvitationByTokenRequiredArguments =
    { invitationToken : String }


{-| Look up a pending enterprise administrator invitation by invitation token.

  - invitationToken - The invitation token sent with the invitation email.

-}
enterpriseAdministratorInvitationByToken :
    EnterpriseAdministratorInvitationByTokenRequiredArguments
    -> SelectionSet decodesTo Github.Object.EnterpriseAdministratorInvitation
    -> SelectionSet (Maybe decodesTo) RootQuery
enterpriseAdministratorInvitationByToken requiredArgs____ object____ =
    Object.selectionForCompositeField "enterpriseAdministratorInvitationByToken" [ Argument.required "invitationToken" requiredArgs____.invitationToken Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias LicenseRequiredArguments =
    { key : String }


{-| Look up an open source license by its key

  - key - The license's downcased SPDX ID

-}
license :
    LicenseRequiredArguments
    -> SelectionSet decodesTo Github.Object.License
    -> SelectionSet (Maybe decodesTo) RootQuery
license requiredArgs____ object____ =
    Object.selectionForCompositeField "license" [ Argument.required "key" requiredArgs____.key Encode.string ] object____ (Basics.identity >> Decode.nullable)


{-| Return a list of known open source licenses
-}
licenses :
    SelectionSet decodesTo Github.Object.License
    -> SelectionSet (List (Maybe decodesTo)) RootQuery
licenses object____ =
    Object.selectionForCompositeField "licenses" [] object____ (Basics.identity >> Decode.nullable >> Decode.list)


type alias MarketplaceCategoriesOptionalArguments =
    { includeCategories : OptionalArgument (List String)
    , excludeEmpty : OptionalArgument Bool
    , excludeSubcategories : OptionalArgument Bool
    }


{-| Get alphabetically sorted list of Marketplace categories

  - includeCategories - Return only the specified categories.
  - excludeEmpty - Exclude categories with no listings.
  - excludeSubcategories - Returns top level categories only, excluding any subcategories.

-}
marketplaceCategories :
    (MarketplaceCategoriesOptionalArguments -> MarketplaceCategoriesOptionalArguments)
    -> SelectionSet decodesTo Github.Object.MarketplaceCategory
    -> SelectionSet (List decodesTo) RootQuery
marketplaceCategories fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { includeCategories = Absent, excludeEmpty = Absent, excludeSubcategories = Absent }

        optionalArgs____ =
            [ Argument.optional "includeCategories" filledInOptionals____.includeCategories (Encode.string |> Encode.list), Argument.optional "excludeEmpty" filledInOptionals____.excludeEmpty Encode.bool, Argument.optional "excludeSubcategories" filledInOptionals____.excludeSubcategories Encode.bool ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "marketplaceCategories" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias MarketplaceCategoryOptionalArguments =
    { useTopicAliases : OptionalArgument Bool }


type alias MarketplaceCategoryRequiredArguments =
    { slug : String }


{-| Look up a Marketplace category by its slug.

  - slug - The URL slug of the category.
  - useTopicAliases - Also check topic aliases for the category slug

-}
marketplaceCategory :
    (MarketplaceCategoryOptionalArguments -> MarketplaceCategoryOptionalArguments)
    -> MarketplaceCategoryRequiredArguments
    -> SelectionSet decodesTo Github.Object.MarketplaceCategory
    -> SelectionSet (Maybe decodesTo) RootQuery
marketplaceCategory fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { useTopicAliases = Absent }

        optionalArgs____ =
            [ Argument.optional "useTopicAliases" filledInOptionals____.useTopicAliases Encode.bool ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "marketplaceCategory" (optionalArgs____ ++ [ Argument.required "slug" requiredArgs____.slug Encode.string ]) object____ (Basics.identity >> Decode.nullable)


type alias MarketplaceListingRequiredArguments =
    { slug : String }


{-| Look up a single Marketplace listing

  - slug - Select the listing that matches this slug. It's the short name of the listing used in its URL.

-}
marketplaceListing :
    MarketplaceListingRequiredArguments
    -> SelectionSet decodesTo Github.Object.MarketplaceListing
    -> SelectionSet (Maybe decodesTo) RootQuery
marketplaceListing requiredArgs____ object____ =
    Object.selectionForCompositeField "marketplaceListing" [ Argument.required "slug" requiredArgs____.slug Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias MarketplaceListingsOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    , categorySlug : OptionalArgument String
    , useTopicAliases : OptionalArgument Bool
    , viewerCanAdmin : OptionalArgument Bool
    , adminId : OptionalArgument Github.ScalarCodecs.Id
    , organizationId : OptionalArgument Github.ScalarCodecs.Id
    , allStates : OptionalArgument Bool
    , slugs : OptionalArgument (List (Maybe String))
    , primaryCategoryOnly : OptionalArgument Bool
    , withFreeTrialsOnly : OptionalArgument Bool
    }


{-| Look up Marketplace listings

  - after - Returns the elements in the list that come after the specified cursor.

  - before - Returns the elements in the list that come before the specified cursor.

  - first - Returns the first _n_ elements from the list.

  - last - Returns the last _n_ elements from the list.

  - categorySlug - Select only listings with the given category.

  - useTopicAliases - Also check topic aliases for the category slug

  - viewerCanAdmin - Select listings to which user has admin access. If omitted, listings visible to the
    viewer are returned.

  - adminId - Select listings that can be administered by the specified user.

  - organizationId - Select listings for products owned by the specified organization.

  - allStates - Select listings visible to the viewer even if they are not approved. If omitted or
    false, only approved listings will be returned.

  - slugs - Select the listings with these slugs, if they are visible to the viewer.

  - primaryCategoryOnly - Select only listings where the primary category matches the given category slug.

  - withFreeTrialsOnly - Select only listings that offer a free trial.

-}
marketplaceListings :
    (MarketplaceListingsOptionalArguments -> MarketplaceListingsOptionalArguments)
    -> SelectionSet decodesTo Github.Object.MarketplaceListingConnection
    -> SelectionSet decodesTo RootQuery
marketplaceListings fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { after = Absent, before = Absent, first = Absent, last = Absent, categorySlug = Absent, useTopicAliases = Absent, viewerCanAdmin = Absent, adminId = Absent, organizationId = Absent, allStates = Absent, slugs = Absent, primaryCategoryOnly = Absent, withFreeTrialsOnly = Absent }

        optionalArgs____ =
            [ Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "categorySlug" filledInOptionals____.categorySlug Encode.string, Argument.optional "useTopicAliases" filledInOptionals____.useTopicAliases Encode.bool, Argument.optional "viewerCanAdmin" filledInOptionals____.viewerCanAdmin Encode.bool, Argument.optional "adminId" filledInOptionals____.adminId (Github.ScalarCodecs.codecs |> Github.Scalar.unwrapEncoder .codecId), Argument.optional "organizationId" filledInOptionals____.organizationId (Github.ScalarCodecs.codecs |> Github.Scalar.unwrapEncoder .codecId), Argument.optional "allStates" filledInOptionals____.allStates Encode.bool, Argument.optional "slugs" filledInOptionals____.slugs (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "primaryCategoryOnly" filledInOptionals____.primaryCategoryOnly Encode.bool, Argument.optional "withFreeTrialsOnly" filledInOptionals____.withFreeTrialsOnly Encode.bool ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "marketplaceListings" optionalArgs____ object____ Basics.identity


{-| Return information about the GitHub instance
-}
meta :
    SelectionSet decodesTo Github.Object.GitHubMetadata
    -> SelectionSet decodesTo RootQuery
meta object____ =
    Object.selectionForCompositeField "meta" [] object____ Basics.identity


type alias NodeRequiredArguments =
    { id : Github.ScalarCodecs.Id }


{-| Fetches an object given its ID.

  - id - ID of the object.

-}
node :
    NodeRequiredArguments
    -> SelectionSet decodesTo Github.Interface.Node
    -> SelectionSet (Maybe decodesTo) RootQuery
node requiredArgs____ object____ =
    Object.selectionForCompositeField "node" [ Argument.required "id" requiredArgs____.id (Github.ScalarCodecs.codecs |> Github.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias NodesRequiredArguments =
    { ids : List Github.ScalarCodecs.Id }


{-| Lookup nodes by a list of IDs.

  - ids - The list of node IDs.

-}
nodes :
    NodesRequiredArguments
    -> SelectionSet decodesTo Github.Interface.Node
    -> SelectionSet (List (Maybe decodesTo)) RootQuery
nodes requiredArgs____ object____ =
    Object.selectionForCompositeField "nodes" [ Argument.required "ids" requiredArgs____.ids ((Github.ScalarCodecs.codecs |> Github.Scalar.unwrapEncoder .codecId) |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list)


type alias OrganizationRequiredArguments =
    { login : String }


{-| Lookup a organization by login.

  - login - The organization's login.

-}
organization :
    OrganizationRequiredArguments
    -> SelectionSet decodesTo Github.Object.Organization
    -> SelectionSet (Maybe decodesTo) RootQuery
organization requiredArgs____ object____ =
    Object.selectionForCompositeField "organization" [ Argument.required "login" requiredArgs____.login Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias RateLimitOptionalArguments =
    { dryRun : OptionalArgument Bool }


{-| The client's rate limit information.

  - dryRun - If true, calculate the cost for the query without evaluating it

-}
rateLimit :
    (RateLimitOptionalArguments -> RateLimitOptionalArguments)
    -> SelectionSet decodesTo Github.Object.RateLimit
    -> SelectionSet (Maybe decodesTo) RootQuery
rateLimit fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { dryRun = Absent }

        optionalArgs____ =
            [ Argument.optional "dryRun" filledInOptionals____.dryRun Encode.bool ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "rateLimit" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


{-| Hack to workaround <https://github.com/facebook/relay/issues/112> re-exposing the root query object
-}
relay :
    SelectionSet decodesTo RootQuery
    -> SelectionSet decodesTo RootQuery
relay object____ =
    Object.selectionForCompositeField "relay" [] object____ Basics.identity


type alias RepositoryOptionalArguments =
    { followRenames : OptionalArgument Bool }


type alias RepositoryRequiredArguments =
    { owner : String
    , name : String
    }


{-| Lookup a given repository by the owner and repository name.

  - owner - The login field of a user or organization
  - name - The name of the repository
  - followRenames - Follow repository renames. If disabled, a repository referenced by its old name will return an error.

-}
repository :
    (RepositoryOptionalArguments -> RepositoryOptionalArguments)
    -> RepositoryRequiredArguments
    -> SelectionSet decodesTo Github.Object.Repository
    -> SelectionSet (Maybe decodesTo) RootQuery
repository fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { followRenames = Absent }

        optionalArgs____ =
            [ Argument.optional "followRenames" filledInOptionals____.followRenames Encode.bool ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "repository" (optionalArgs____ ++ [ Argument.required "owner" requiredArgs____.owner Encode.string, Argument.required "name" requiredArgs____.name Encode.string ]) object____ (Basics.identity >> Decode.nullable)


type alias RepositoryOwnerRequiredArguments =
    { login : String }


{-| Lookup a repository owner (ie. either a User or an Organization) by login.

  - login - The username to lookup the owner by.

-}
repositoryOwner :
    RepositoryOwnerRequiredArguments
    -> SelectionSet decodesTo Github.Interface.RepositoryOwner
    -> SelectionSet (Maybe decodesTo) RootQuery
repositoryOwner requiredArgs____ object____ =
    Object.selectionForCompositeField "repositoryOwner" [ Argument.required "login" requiredArgs____.login Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias ResourceRequiredArguments =
    { url : Github.ScalarCodecs.Uri }


{-| Lookup resource by a URL.

  - url - The URL.

-}
resource :
    ResourceRequiredArguments
    -> SelectionSet decodesTo Github.Interface.UniformResourceLocatable
    -> SelectionSet (Maybe decodesTo) RootQuery
resource requiredArgs____ object____ =
    Object.selectionForCompositeField "resource" [ Argument.required "url" requiredArgs____.url (Github.ScalarCodecs.codecs |> Github.Scalar.unwrapEncoder .codecUri) ] object____ (Basics.identity >> Decode.nullable)


type alias SearchOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


type alias SearchRequiredArguments =
    { query : String
    , type_ : Github.Enum.SearchType.SearchType
    }


{-| Perform a search across resources, returning a maximum of 1,000 results.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.
  - query - The search string to look for.
  - type\_ - The types of search items to search within.

-}
search :
    (SearchOptionalArguments -> SearchOptionalArguments)
    -> SearchRequiredArguments
    -> SelectionSet decodesTo Github.Object.SearchResultItemConnection
    -> SelectionSet decodesTo RootQuery
search fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs____ =
            [ Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "search" (optionalArgs____ ++ [ Argument.required "query" requiredArgs____.query Encode.string, Argument.required "type" requiredArgs____.type_ (Encode.enum Github.Enum.SearchType.toString) ]) object____ Basics.identity


type alias SecurityAdvisoriesOptionalArguments =
    { orderBy : OptionalArgument Github.InputObject.SecurityAdvisoryOrder
    , identifier : OptionalArgument Github.InputObject.SecurityAdvisoryIdentifierFilter
    , publishedSince : OptionalArgument Github.ScalarCodecs.DateTime
    , updatedSince : OptionalArgument Github.ScalarCodecs.DateTime
    , classifications : OptionalArgument (List Github.Enum.SecurityAdvisoryClassification.SecurityAdvisoryClassification)
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| GitHub Security Advisories

  - orderBy - Ordering options for the returned topics.
  - identifier - Filter advisories by identifier, e.g. GHSA or CVE.
  - publishedSince - Filter advisories to those published since a time in the past.
  - updatedSince - Filter advisories to those updated since a time in the past.
  - classifications - A list of classifications to filter advisories by.
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
securityAdvisories :
    (SecurityAdvisoriesOptionalArguments -> SecurityAdvisoriesOptionalArguments)
    -> SelectionSet decodesTo Github.Object.SecurityAdvisoryConnection
    -> SelectionSet decodesTo RootQuery
securityAdvisories fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { orderBy = Absent, identifier = Absent, publishedSince = Absent, updatedSince = Absent, classifications = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs____ =
            [ Argument.optional "orderBy" filledInOptionals____.orderBy Github.InputObject.encodeSecurityAdvisoryOrder, Argument.optional "identifier" filledInOptionals____.identifier Github.InputObject.encodeSecurityAdvisoryIdentifierFilter, Argument.optional "publishedSince" filledInOptionals____.publishedSince (Github.ScalarCodecs.codecs |> Github.Scalar.unwrapEncoder .codecDateTime), Argument.optional "updatedSince" filledInOptionals____.updatedSince (Github.ScalarCodecs.codecs |> Github.Scalar.unwrapEncoder .codecDateTime), Argument.optional "classifications" filledInOptionals____.classifications (Encode.enum Github.Enum.SecurityAdvisoryClassification.toString |> Encode.list), Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "securityAdvisories" optionalArgs____ object____ Basics.identity


type alias SecurityAdvisoryRequiredArguments =
    { ghsaId : String }


{-| Fetch a Security Advisory by its GHSA ID

  - ghsaId - GitHub Security Advisory ID.

-}
securityAdvisory :
    SecurityAdvisoryRequiredArguments
    -> SelectionSet decodesTo Github.Object.SecurityAdvisory
    -> SelectionSet (Maybe decodesTo) RootQuery
securityAdvisory requiredArgs____ object____ =
    Object.selectionForCompositeField "securityAdvisory" [ Argument.required "ghsaId" requiredArgs____.ghsaId Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias SecurityVulnerabilitiesOptionalArguments =
    { orderBy : OptionalArgument Github.InputObject.SecurityVulnerabilityOrder
    , ecosystem : OptionalArgument Github.Enum.SecurityAdvisoryEcosystem.SecurityAdvisoryEcosystem
    , package : OptionalArgument String
    , severities : OptionalArgument (List Github.Enum.SecurityAdvisorySeverity.SecurityAdvisorySeverity)
    , classifications : OptionalArgument (List Github.Enum.SecurityAdvisoryClassification.SecurityAdvisoryClassification)
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-| Software Vulnerabilities documented by GitHub Security Advisories

  - orderBy - Ordering options for the returned topics.
  - ecosystem - An ecosystem to filter vulnerabilities by.
  - package - A package name to filter vulnerabilities by.
  - severities - A list of severities to filter vulnerabilities by.
  - classifications - A list of advisory classifications to filter vulnerabilities by.
  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.

-}
securityVulnerabilities :
    (SecurityVulnerabilitiesOptionalArguments -> SecurityVulnerabilitiesOptionalArguments)
    -> SelectionSet decodesTo Github.Object.SecurityVulnerabilityConnection
    -> SelectionSet decodesTo RootQuery
securityVulnerabilities fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { orderBy = Absent, ecosystem = Absent, package = Absent, severities = Absent, classifications = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs____ =
            [ Argument.optional "orderBy" filledInOptionals____.orderBy Github.InputObject.encodeSecurityVulnerabilityOrder, Argument.optional "ecosystem" filledInOptionals____.ecosystem (Encode.enum Github.Enum.SecurityAdvisoryEcosystem.toString), Argument.optional "package" filledInOptionals____.package Encode.string, Argument.optional "severities" filledInOptionals____.severities (Encode.enum Github.Enum.SecurityAdvisorySeverity.toString |> Encode.list), Argument.optional "classifications" filledInOptionals____.classifications (Encode.enum Github.Enum.SecurityAdvisoryClassification.toString |> Encode.list), Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "securityVulnerabilities" optionalArgs____ object____ Basics.identity


type alias SponsorablesOptionalArguments =
    { after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    , orderBy : OptionalArgument Github.InputObject.SponsorableOrder
    , onlyDependencies : OptionalArgument Bool
    , orgLoginForDependencies : OptionalArgument String
    , dependencyEcosystem : OptionalArgument Github.Enum.SecurityAdvisoryEcosystem.SecurityAdvisoryEcosystem
    , ecosystem : OptionalArgument Github.Enum.DependencyGraphEcosystem.DependencyGraphEcosystem
    }


{-| Users and organizations who can be sponsored via GitHub Sponsors.

  - after - Returns the elements in the list that come after the specified cursor.
  - before - Returns the elements in the list that come before the specified cursor.
  - first - Returns the first _n_ elements from the list.
  - last - Returns the last _n_ elements from the list.
  - orderBy - Ordering options for users and organizations returned from the connection.
  - onlyDependencies - Whether only sponsorables who own the viewer's dependencies will be returned. Must be authenticated to use. Can check an organization instead for their dependencies owned by sponsorables by passing orgLoginForDependencies.
  - orgLoginForDependencies - Optional organization username for whose dependencies should be checked. Used when onlyDependencies = true. Omit to check your own dependencies. If you are not an administrator of the organization, only dependencies from its public repositories will be considered.
  - dependencyEcosystem - Optional filter for which dependencies should be checked for sponsorable owners. Only sponsorable owners of dependencies in this ecosystem will be included. Used when onlyDependencies = true.

**Upcoming Change on 2022-07-01 UTC**
**Description:** `dependencyEcosystem` will be removed. Use the ecosystem argument instead.
**Reason:** The type is switching from SecurityAdvisoryEcosystem to DependencyGraphEcosystem.

  - ecosystem - Optional filter for which dependencies should be checked for sponsorable owners. Only sponsorable owners of dependencies in this ecosystem will be included. Used when onlyDependencies = true.

-}
sponsorables :
    (SponsorablesOptionalArguments -> SponsorablesOptionalArguments)
    -> SelectionSet decodesTo Github.Object.SponsorableItemConnection
    -> SelectionSet decodesTo RootQuery
sponsorables fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { after = Absent, before = Absent, first = Absent, last = Absent, orderBy = Absent, onlyDependencies = Absent, orgLoginForDependencies = Absent, dependencyEcosystem = Absent, ecosystem = Absent }

        optionalArgs____ =
            [ Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "orderBy" filledInOptionals____.orderBy Github.InputObject.encodeSponsorableOrder, Argument.optional "onlyDependencies" filledInOptionals____.onlyDependencies Encode.bool, Argument.optional "orgLoginForDependencies" filledInOptionals____.orgLoginForDependencies Encode.string, Argument.optional "dependencyEcosystem" filledInOptionals____.dependencyEcosystem (Encode.enum Github.Enum.SecurityAdvisoryEcosystem.toString), Argument.optional "ecosystem" filledInOptionals____.ecosystem (Encode.enum Github.Enum.DependencyGraphEcosystem.toString) ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "sponsorables" optionalArgs____ object____ Basics.identity


type alias TopicRequiredArguments =
    { name : String }


{-| Look up a topic by name.

  - name - The topic's name.

-}
topic :
    TopicRequiredArguments
    -> SelectionSet decodesTo Github.Object.Topic
    -> SelectionSet (Maybe decodesTo) RootQuery
topic requiredArgs____ object____ =
    Object.selectionForCompositeField "topic" [ Argument.required "name" requiredArgs____.name Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias UserRequiredArguments =
    { login : String }


{-| Lookup a user by login.

  - login - The user's login.

-}
user :
    UserRequiredArguments
    -> SelectionSet decodesTo Github.Object.User
    -> SelectionSet (Maybe decodesTo) RootQuery
user requiredArgs____ object____ =
    Object.selectionForCompositeField "user" [ Argument.required "login" requiredArgs____.login Encode.string ] object____ (Basics.identity >> Decode.nullable)


{-| The currently authenticated user.
-}
viewer :
    SelectionSet decodesTo Github.Object.User
    -> SelectionSet decodesTo RootQuery
viewer object____ =
    Object.selectionForCompositeField "viewer" [] object____ Basics.identity
